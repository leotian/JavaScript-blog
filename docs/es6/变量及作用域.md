# 变量及作用域

## 变量的声明和解构赋值

### 一、let命令和const命令

1. let所声明的变量，只在let命令所在的代码块内有效。

2. for循环的计数器，用let声明只在for循环体内有效，var声明的全局有效：

   ```JavaScript
   var a = [];
   for (var i = 0; i < 10; i++) {
     a[i] = function () {
       console.log(i);
     };
   }
   a[6](); // 10
   
   var a = [];
   for (let i = 0; i < 10; i++) {
     a[i] = function () {
       console.log(i);
     };
   }
   a[6]();	// 改为let声明，输出6，正确，每次循环的i都是一个新变量，只在本次循环有效
   ```

   for循环特别之处在于设置循环变量的部分为一个父作用域，而循环体是一个单独的子作用域：

   ```javascript
   for (let i = 0; i < 3; i++) {
     let i = 'abc';
     console.log(i);
   }
   // abc
   // abc
   // abc
   ```

3. 不存在变量提升（这点存在争议，其实是声明提升而初始化不提升，具体看[这里](https://sinaad.github.io/xfe/2016/02/26/temporal-dead-zone-tdz-demystified/)），let 所声明的变量一定要在初始化后使用，否则报错：

   ```javascript
   console.log(baz);	// Uncaught ReferenceError: baz is not defined
   
   // var 的情况
   console.log(foo); // 输出undefined
   var foo = 2;
   
   // let 的情况
   console.log(bar);
   let bar = 2;	// Uncaught ReferenceError: Cannot access 'bar' before initialization
   ```

   暂时性死区（temporal dead zone：TDZ），只要块级作用域内存在let命令，它所声明的变量就绑定了这个区域，不再受外部影响：

   ```javascript
   var tmp = 123;
   
   if (true) {
     tmp = 'abc';
     let tmp;
   }	// Uncaught ReferenceError: Cannot access 'tmp' before initialization
   ```

   总之，代码块内使用let，变量声明之前都是不可用的，这也意味着typeof不再百分百安全：

   ```javascript
   typeof x;
   let x;	// Uncaught ReferenceError: Cannot access 'x' before initialization
   
   typeof y;
   "undefined"	// 没有let之前，typeof是百分比安全的
   ```

   隐蔽的死区：

   ```js
   function bar(x = y, y = 2) { // 未声明先使用
     return [x, y];
   }
   
   bar();	// Uncaught ReferenceError: Cannot access 'y' before initialization
   
   var x = x;	// 不报错
   let y = y;	// Uncaught ReferenceError: Cannot access 'y' before initialization
   ```

   ES6规定暂时性死区和let、const语句不出现变量提升，主要为减少运行时错误，防止变量声明前就使用。暂时性死区的本质就是当进入当前作用域，虽然所使用变量都已存在，但是只有在声明语句后才能获取和使用。

5. 不允许重复声明，let不允许在相同作用域内重复声明同一变量：

   ```javascript
   function func() {
     let a = 10;
     var a = 1;
   } // Uncaught SyntaxError: Identifier 'a' has already been declared
   
   function func() {
     let a = 10;
     let a = 1;
   }	// Uncaught SyntaxError: Identifier 'a' has already been declared
   ```

   同样也就不能在函数内部重新声明参数（和for循环略不同）：

   ```javascript
   function func(arg) {
     let arg;
   }
   func() // Uncaught SyntaxError: Identifier 'arg' has already been declared
   
   function func(arg) {
     {
       let arg;
     }
   }
   func() // 不报错
   ```

6. const声明一个只读变量，一旦声明，常量的值不能改变：

   ```js
   const PI = 3.1415;
   PI // 3.1415
   
   PI = 3;	// Uncaught TypeError: Assignment to constant variable.
   ```

   这意味着，const一旦声明变量，就必须立即初始化，不能只声明不赋值：

   ```javascript
   const foo;	// Uncaught SyntaxError: Missing initializer in const declaration
   ```

7. const的作用域与let命令相同：只在声明所在的块级作用域内有效。

8. const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

9. const声明的常量，也与let一样不可重复声明。

9. 对于引用类型，const只能保证[引用（即指针）](https://leotian.cn/posts/c92b/)不变，引用的值改变无法保证。

10. ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，加上另外两种声明变量的方法：import命令和class命令，ES6 一共有 6 种声明变量的方法。

### 二、变量的解构赋值

1. 

## 变量的作用域

### 一、块级作用域



### 二、全局作用域


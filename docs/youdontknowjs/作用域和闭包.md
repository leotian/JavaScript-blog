   * [作用域是什么](#作用域是什么)
      * [编译原理](#编译原理)
      * [理解作用域](#理解作用域)
      * [作用域嵌套](#作用域嵌套)
      * [异常](#异常)
   * [词法作用域](#词法作用域)

# 作用域是什么

## 编译原理

1. JavaScript 即是一门“动态”或“解释执行”语言，也是一门“编译语言”（需要编译才能执行，实际上Python也是），但不是提前编译，而且编译结果也不能在分布式系统中进行移植。
2. 编译三步骤：分词/词法分析（Tokenizing/Lexing）→ 解释/语法分析（Parsing 生成AST语法树）→ 代码生成

## 理解作用域

1. 参与程序执行的三部分：

   - 引擎：从头到尾负责整个JavaScript程序的编译和执行过程
   - 编译器：负责语法分析及代码生成
   - 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行代码对这些标识符的防问权限

   `var a = 2;` 的执行过程：

   1. 首先，var a在其作用域中声明新变量（如果之前没有声明过）。这会在最开始的阶段，也就是代码执行前进行。
   2. 接下来，代码执行，a = 2 会查询（LHS查询）变量 a 并对其进行赋值。

2. 编译器在编译过程的最后生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。有两种查找方式：

   - LHS：查找赋值操作的目标
   - RHS：得到xx的值，也就是 retrieve his source value（取到它的源值）。

   不可以将函数声明function foo(a) {...概念化为普通的变量声明和赋值，比如var foo、foo = function(a){...。

   编译器可以在代码生成的同时处理声明和值的定义（默认undefined）。

## 作用域嵌套

1. LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

## 异常

1. 不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出Refer-enceError异常（严格模式下）。
2. 如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

# 词法作用域

作用域分为词法作用域和动态作用域（使用较少，典型的如Bash脚本）

## 此法阶段

1. 编译器的第一个阶段为词法化（也叫单词化）。
2. 词法作用域就是定义在词法阶段的作用域，也就是由写代码时变量和块作用域的位置来决定（大部分情况，但会有一些欺骗词法作用域的方法）。
3. 作用域逐级包含，不存在边界跨越的情况。

### 查找

1. 作用域查找始终从运行时所处的最内部作用域开始，逐级向上进行，直到找到第一个匹配的标识符为止，多层嵌套作用域定义同名标识符，会发生“遮蔽效应”。
2. 全局变量会自动成为全局对象的属性（比如浏览器的window对象），可以通过全局对象访问被遮蔽的全局变量，但非全局的变量如果被遮蔽，无论如何访问不到。
3. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
4. 词法作用域查找只会查找一级标识符，比如词法作用域查找只会查找一级标识符，比如 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

## 欺骗词法

1. eval（new Function(..)类似）和with可以修改（或欺骗）词法作用域，不过性能不高，不建议使用
2. 严格模式中，eval（…）在运行时有其自己的词法作用域，意味着其中的声明无法修改所在作用域。
3. 严格模式完全禁止使用with。

# 函数作用域和块作用域

作用域是一系列容器，包含了标识符（变量、函数）的定义。

## 函数中的作用域

1. 函数作用域的含义是指，属于这个函数的全部变量（也就是定义在函数内）都可以在整个函数的范围内使用及复用（在函数内部嵌套的作用域中也可以使用）。

## 隐藏的内部实现

1. 可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来”隐藏“它们。
2. 最小特权原则，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
3. ”隐藏“变量和函数是一项有用的技术，如果所有变量和函数都在全局作用域中，虽然可以在所有的内部嵌套作用域中访问。但会破坏最小特权原则，暴漏过多本应该是私有的变量，正确的处理方式是应该阻止对这些变量或函数进行随意访问。

### 规避冲突

1. “隐藏“作用域中的变量和函数的另一个好处是可以规避同名标识符之间的冲突。两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。
2. 当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象或函数（如jQuery/$）。这个对象被用作库的命名空间，所有需要暴露给外界的功能作为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。

## 函数作用域

1. 区分函数声明和函数表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式，如 `(function …`。
2. 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处，`(function foo(){ .. }) `作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

### 匿名和具名

1. 函数表达式最常见的场景是回调函数，如：`setTimeout(function() { console.log('xxx'); }, 1000);`函数表达式可以是匿名的，而函数声明则不可以省略函数名——这在 JavaScript的语法中是非法的。
2. 匿名表达式有一些缺点，如：
   - 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
   - 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。
   - 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。
3. 所以行内函数表达式非常强大且有用，但匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践。如：`setTimeout(function timeoutHandler() { console.log( "xxx" ); }, 1000);`

### 立即执行函数表达式

1. IIFE，代表立即执行函数表达式 （Immediately Invoked Function Expression），由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，如`(function foo() { console.log('xxx'); })();`第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。
2. 函数名对 IIFE 不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。
3. IIFE还有一种改进形式，`(function(){ .. }())`，这两种形式在功能上是一致的。
4. IIFE传递参数并调用有多种用途，如解决 undefined 标识符的默认值被错误覆盖导致的异常（不常见）、倒置代码的运行顺序（UMD）等。

## 块作用域

1. 块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。

### with

1. 块作用域的一种形式。

### try/catch

1. ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。
2. catch 分句具有块作用域，因此它可以在 ES6 之前的环境中作为块作用域的替代方案，模拟实现块作用域。

### let

1. ES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。可以使用 { .. } 括号来为 let 创建一个用于绑定的块，如果没有显式的{}，那么会隐式绑定在最近的块（花括号包含的区域）中。
2. 
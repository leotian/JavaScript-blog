<!--ts-->

   * [作用域是什么](#作用域是什么)
      * [编译原理](#编译原理)
      * [理解作用域](#理解作用域)
      * [作用域嵌套](#作用域嵌套)
      * [异常](#异常)
   * [词法作用域](#词法作用域)

<!-- Added by: tyb, at: Thu Jun 27 18:32:38 CST 2019 -->

<!--te-->

# 作用域是什么

## 编译原理

1. JavaScript 即是一门“动态”或“解释执行”语言，也是一门“编译语言”（需要编译才能执行，实际上Python也是），但不是提前编译，而且编译结果也不能在分布式系统中进行移植。
2. 编译三步骤：分词/词法分析（Tokenizing/Lexing）→ 解释/语法分析（Parsing 生成AST语法树）→ 代码生成

## 理解作用域

1. 参与程序执行的三部分：

   - 引擎：从头到尾负责整个JavaScript程序的编译和执行过程
   - 编译器：负责语法分析及代码生成
   - 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行代码对这些标识符的防问权限

   `var a = 2;` 的执行过程：

   1. 首先，var a在其作用域中声明新变量（如果之前没有声明过）。这会在最开始的阶段，也就是代码执行前进行。
   2. 接下来，代码执行，a = 2 会查询（LHS查询）变量 a 并对其进行赋值。

2. 编译器在编译过程的最后生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。有两种查找方式：

   - LHS：查找赋值操作的目标
   - RHS：得到xx的值，也就是 retrieve his source value（取到它的源值）。

   不可以将函数声明function foo(a) {...概念化为普通的变量声明和赋值，比如var foo、foo = function(a){...。

   编译器可以在代码生成的同时处理声明和值的定义（默认undefined）。

## 作用域嵌套

1. LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

## 异常

1. 不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出Refer-enceError异常（严格模式下）。
2. 如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

# 词法作用域



